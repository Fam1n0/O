<html>
<head>
  <meta charset="UTF-8">
  <title>Advanced Edge Detection Tool</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Include OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>

  <style>
    /* Reset and basic styles */
    * {
      box-sizing: border-box;
    }
    body, html {
      margin: 0;
      padding: 0;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    /* Canvas and Video */
    #canvasWrapper {
      position: relative;
      width: 100%;
      height: 100%;
    }
    canvas, video {
      width: 100%;
      height: 100%;
      position: absolute;
    }
    video {
      display: none;
    }
    /* Control Panel */
    #controlPanel {
      position: absolute;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, 0.6);
      padding: 10px 20px;
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    #controlPanel.collapsed {
      display: none;
    }
    #controlPanel > * {
      margin: 5px;
    }
    #controlPanel label {
      margin-right: 5px;
    }
    #controlPanel input[type="range"] {
      width: 100px;
    }
    #controlPanel select, #controlPanel input[type="color"] {
      padding: 5px;
    }
    /* Disabled Slider */
    #kernelSizeRange:disabled {
      opacity: 0.5;
    }
    /* Buttons */
    #saveButton, #fullscreenButton, #toggleControlPanel, #uploadButton, #saveConfigButton, #loadConfigButton {
      position: absolute;
      top: 20px;
      padding: 10px 15px;
      background-color: rgba(255, 255, 255, 0.15);
      border: none;
      border-radius: 50%;
      font-size: 20px;
      color: #fff;
      cursor: pointer;
      z-index: 10;
    }
    #saveButton:hover, #fullscreenButton:hover, #toggleControlPanel:hover, #uploadButton:hover, #saveConfigButton:hover, #loadConfigButton:hover {
      background-color: rgba(255, 255, 255, 0.25);
    }
    #saveButton {
      right: 20px;
    }
    #fullscreenButton {
      right: 80px;
    }
    #toggleControlPanel {
      bottom: 20px;
      top: unset;
      left: 50%;
      transform: translateX(-50%);
      border-radius: 10px;
      font-size: 16px;
    }
    #uploadButton {
      right: 140px;
    }
    #saveConfigButton, #loadConfigButton {
      top: 80px;
    }
    #saveConfigButton {
      right: 20px;
    }
    #loadConfigButton {
      right: 80px;
    }
    /* Media Queries */
    @media (max-width: 600px) {
      #controlPanel {
        flex-direction: column;
      }
      #controlPanel > * {
        margin: 10px 0;
      }
    }
  </style>
</head>
<body>
  <div id="canvasWrapper">
    <video id="videoElement" autoplay playsinline></video>
    <canvas id="mainCanvas"></canvas>

    <!-- Control Panel -->
    <div id="controlPanel">
      <label for="presetSelect">Presets:</label>
      <select id="presetSelect">
        <option value="">Custom</option>
        <option value="outline">Outline</option>
        <option value="sketch">Sketch</option>
        <option value="detailed">Detailed</option>
      </select>

      <label for="methodSelect">Method:</label>
      <select id="methodSelect">
        <option value="sobel">Sobel</option>
        <option value="prewitt">Prewitt</option>
        <option value="laplacian">Laplacian</option>
        <option value="canny">Canny</option>
      </select>

      <label for="thresholdRange">Threshold:</label>
      <input type="range" id="thresholdRange" min="0" max="255" value="100">

      <label for="kernelSizeRange">Kernel Size:</label>
      <input type="range" id="kernelSizeRange" min="3" max="7" step="2" value="3">

      <label for="blurRange">Gaussian Blur:</label>
      <input type="range" id="blurRange" min="0" max="5" value="0">

      <label for="contrastRange">Contrast:</label>
      <input type="range" id="contrastRange" min="-100" max="100" value="0">

      <label for="brightnessRange">Brightness:</label>
      <input type="range" id="brightnessRange" min="-100" max="100" value="0">

      <label for="colorizeCheckbox">Colorize Edges:</label>
      <input type="checkbox" id="colorizeCheckbox">

      <input type="color" id="edgeColorPicker" value="#ffffff" style="display:none;">
    </div>

    <!-- Buttons -->
    <button id="saveButton" aria-label="Save Image">💾</button>
    <button id="fullscreenButton" aria-label="Toggle Fullscreen">⛶</button>
    <button id="uploadButton" aria-label="Upload Image">⤴</button>
    <button id="toggleControlPanel">Controls ▲</button>
    <button id="saveConfigButton" aria-label="Save Configuration">💾 Config</button>
    <button id="loadConfigButton" aria-label="Load Configuration">📂 Config</button>

    <!-- Hidden File Input -->
    <input type="file" id="imageUpload" accept="image/*" style="display: none;">
  </div>

  <script>
    let cvReady = false;
    cv['onRuntimeInitialized'] = () => {
      cvReady = true;
      initApp();
    };

    function initApp() {
      const video = document.getElementById('videoElement');
      const canvas = document.getElementById('mainCanvas');
      const ctx = canvas.getContext('2d');

      const methodSelect = document.getElementById('methodSelect');
      const thresholdRange = document.getElementById('thresholdRange');
      const kernelSizeRange = document.getElementById('kernelSizeRange');
      const blurRange = document.getElementById('blurRange');
      const colorizeCheckbox = document.getElementById('colorizeCheckbox');
      const edgeColorPicker = document.getElementById('edgeColorPicker');
      const saveButton = document.getElementById('saveButton');
      const fullscreenButton = document.getElementById('fullscreenButton');
      const toggleControlPanelButton = document.getElementById('toggleControlPanel');
      const controlPanel = document.getElementById('controlPanel');
      const uploadButton = document.getElementById('uploadButton');
      const imageUpload = document.getElementById('imageUpload');
      const presetSelect = document.getElementById('presetSelect');
      const contrastRange = document.getElementById('contrastRange');
      const brightnessRange = document.getElementById('brightnessRange');
      const saveConfigButton = document.getElementById('saveConfigButton');
      const loadConfigButton = document.getElementById('loadConfigButton');

      let threshold = parseInt(thresholdRange.value, 10);
      let kernelSize = parseInt(kernelSizeRange.value, 10);
      let blurRadius = parseInt(blurRange.value, 10);
      let edgeMethod = methodSelect.value;
      let colorizeEdges = colorizeCheckbox.checked;
      let edgeColor = edgeColorPicker.value;
      let contrast = parseInt(contrastRange.value, 10);
      let brightness = parseInt(brightnessRange.value, 10);

      // Set canvas size to fill the screen
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }

      // Update settings when controls change
      thresholdRange.addEventListener('input', (e) => {
        threshold = parseInt(e.target.value, 10);
        e.target.title = `Threshold: ${threshold}`;
      });

      kernelSizeRange.addEventListener('input', (e) => {
        kernelSize = parseInt(e.target.value, 10);
        e.target.title = `Kernel Size: ${kernelSize}`;
      });

      blurRange.addEventListener('input', (e) => {
        blurRadius = parseInt(e.target.value, 10);
        e.target.title = `Blur Radius: ${blurRadius}`;
      });

      contrastRange.addEventListener('input', (e) => {
        contrast = parseInt(e.target.value, 10);
        e.target.title = `Contrast: ${contrast}`;
      });

      brightnessRange.addEventListener('input', (e) => {
        brightness = parseInt(e.target.value, 10);
        e.target.title = `Brightness: ${brightness}`;
      });

      methodSelect.addEventListener('change', (e) => {
        edgeMethod = e.target.value;
        // Enable kernel size only for Laplacian
        if (edgeMethod === 'laplacian') {
          kernelSizeRange.disabled = false;
        } else {
          kernelSizeRange.disabled = true;
        }
      });

      colorizeCheckbox.addEventListener('change', (e) => {
        colorizeEdges = e.target.checked;
        edgeColorPicker.style.display = colorizeEdges ? 'inline-block' : 'none';
      });

      edgeColorPicker.addEventListener('input', (e) => {
        edgeColor = e.target.value;
      });

      presetSelect.addEventListener('change', (e) => {
        switch (e.target.value) {
          case 'outline':
            thresholdRange.value = 150;
            blurRange.value = 1;
            methodSelect.value = 'sobel';
            break;
          case 'sketch':
            thresholdRange.value = 100;
            blurRange.value = 2;
            methodSelect.value = 'prewitt';
            break;
          case 'detailed':
            thresholdRange.value = 50;
            blurRange.value = 0;
            methodSelect.value = 'laplacian';
            break;
          default:
            // Custom settings
            break;
        }
        // Trigger input events to update variables
        thresholdRange.dispatchEvent(new Event('input'));
        blurRange.dispatchEvent(new Event('input'));
        methodSelect.dispatchEvent(new Event('change'));
      });

      // Initialize Camera Stream
      async function initCamera() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
          video.srcObject = stream;
          video.play();
          video.addEventListener('loadeddata', () => {
            requestAnimationFrame(processFrame);
          });
        } catch (err) {
          alert("Error accessing camera: " + err.message);
        }
      }

      // Process Video Frame
      function processFrame() {
        if (!cvReady) {
          requestAnimationFrame(processFrame);
          return;
        }

        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        adjustContrastBrightness(imageData);
        applyEdgeDetection(imageData);
        requestAnimationFrame(processFrame);
      }

      // Adjust Contrast and Brightness
      function adjustContrastBrightness(imageData) {
        const data = imageData.data;
        const factor = (259 * (contrast + 255)) / (255 * (259 - contrast));
        for (let i = 0; i < data.length; i += 4) {
          data[i] = factor * (data[i] - 128) + 128 + brightness;
          data[i + 1] = factor * (data[i + 1] - 128) + 128 + brightness;
          data[i + 2] = factor * (data[i + 2] - 128) + 128 + brightness;
        }
        ctx.putImageData(imageData, 0, 0);
      }

      // Edge Detection Function using OpenCV.js
      function applyEdgeDetection(imageData) {
        const src = cv.matFromImageData(imageData);
        let dst = new cv.Mat();
        let gray = new cv.Mat();
        let edge = new cv.Mat();

        // Convert to grayscale
        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);

        // Apply Gaussian Blur if enabled
        if (blurRadius > 0) {
          let ksize = new cv.Size(blurRadius * 2 + 1, blurRadius * 2 + 1);
          cv.GaussianBlur(gray, gray, ksize, 0, 0, cv.BORDER_DEFAULT);
        }

        // Edge detection
        switch (edgeMethod) {
          case 'canny':
            cv.Canny(gray, edge, threshold, threshold * 2);
            break;
          case 'sobel':
            let gradX = new cv.Mat();
            let gradY = new cv.Mat();
            cv.Sobel(gray, gradX, cv.CV_16S, 1, 0, kernelSize);
            cv.Sobel(gray, gradY, cv.CV_16S, 0, 1, kernelSize);
            cv.convertScaleAbs(gradX, gradX);
            cv.convertScaleAbs(gradY, gradY);
            cv.addWeighted(gradX, 0.5, gradY, 0.5, 0, edge);
            gradX.delete(); gradY.delete();
            break;
          case 'prewitt':
            // Prewitt kernel simulation
            let kernelX = cv.matFromArray(3, 3, cv.CV_32F, [-1, 0, 1, -1, 0, 1, -1, 0, 1]);
            let kernelY = cv.matFromArray(3, 3, cv.CV_32F, [-1, -1, -1, 0, 0, 0, 1, 1, 1]);
            let gradX_prewitt = new cv.Mat();
            let gradY_prewitt = new cv.Mat();
            cv.filter2D(gray, gradX_prewitt, cv.CV_16S, kernelX);
            cv.filter2D(gray, gradY_prewitt, cv.CV_16S, kernelY);
            cv.convertScaleAbs(gradX_prewitt, gradX_prewitt);
            cv.convertScaleAbs(gradY_prewitt, gradY_prewitt);
            cv.addWeighted(gradX_prewitt, 0.5, gradY_prewitt, 0.5, 0, edge);
            gradX_prewitt.delete(); gradY_prewitt.delete();
            kernelX.delete(); kernelY.delete();
            break;
          case 'laplacian':
            cv.Laplacian(gray, edge, cv.CV_16S, kernelSize, 1, 0, cv.BORDER_DEFAULT);
            cv.convertScaleAbs(edge, edge);
            break;
          default:
            cv.Canny(gray, edge, threshold, threshold * 2);
            break;
        }

        // Apply threshold
        cv.threshold(edge, edge, threshold, 255, cv.THRESH_BINARY);

        // Convert single channel image back to RGBA
        cv.cvtColor(edge, dst, cv.COLOR_GRAY2RGBA);

        // Apply edge color if colorizeEdges is enabled
        if (colorizeEdges) {
          let data = dst.data;
          const r = parseInt(edgeColor.slice(1, 3), 16);
          const g = parseInt(edgeColor.slice(3, 5), 16);
          const b = parseInt(edgeColor.slice(5, 7), 16);
          for (let i = 0; i < data.length; i += 4) {
            if (data[i] > 0) {
              data[i] = r;
              data[i + 1] = g;
              data[i + 2] = b;
            }
          }
        }

        // Put the processed data back to the canvas
        const outputImageData = new ImageData(new Uint8ClampedArray(dst.data), dst.cols, dst.rows);
        ctx.putImageData(outputImageData, 0, 0);

        // Clean up
        src.delete();
        dst.delete();
        gray.delete();
        edge.delete();
      }

      // Save Image
      saveButton.addEventListener('click', () => {
        const link = document.createElement('a');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        link.href = canvas.toDataURL('image/png');
        link.download = `edge-detection-${timestamp}.png`;
        link.click();
      });

      // Fullscreen Toggle
      fullscreenButton.addEventListener('click', () => {
        if (!document.fullscreenElement) {
          document.documentElement.requestFullscreen();
          fullscreenButton.textContent = '⏏';
        } else {
          if (document.exitFullscreen) {
            document.exitFullscreen();
            fullscreenButton.textContent = '⛶';
          }
        }
      });

      // Toggle Control Panel
      toggleControlPanelButton.addEventListener('click', () => {
        if (controlPanel.classList.contains('collapsed')) {
          controlPanel.classList.remove('collapsed');
          toggleControlPanelButton.textContent = 'Controls ▲';
        } else {
          controlPanel.classList.add('collapsed');
          toggleControlPanelButton.textContent = 'Controls ▼';
        }
      });

      // Image Upload
      uploadButton.addEventListener('click', () => {
        imageUpload.click();
      });

      imageUpload.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const img = new Image();
          img.onload = function () {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            adjustContrastBrightness(imageData);
            applyEdgeDetection(imageData);
          };
          img.src = URL.createObjectURL(file);
        }
      });

      // Save Configuration
      saveConfigButton.addEventListener('click', () => {
        const config = {
          threshold,
          kernelSize,
          blurRadius,
          edgeMethod,
          colorizeEdges,
          edgeColor,
          contrast,
          brightness
        };
        localStorage.setItem('edgeDetectionConfig', JSON.stringify(config));
        alert('Configuration saved!');
      });

      // Load Configuration
      loadConfigButton.addEventListener('click', () => {
        const config = JSON.parse(localStorage.getItem('edgeDetectionConfig'));
        if (config) {
          thresholdRange.value = config.threshold;
          kernelSizeRange.value = config.kernelSize;
          blurRange.value = config.blurRadius;
          methodSelect.value = config.edgeMethod;
          colorizeCheckbox.checked = config.colorizeEdges;
          edgeColorPicker.value = config.edgeColor;
          contrastRange.value = config.contrast;
          brightnessRange.value = config.brightness;

          // Dispatch events to update variables
          thresholdRange.dispatchEvent(new Event('input'));
          kernelSizeRange.dispatchEvent(new Event('input'));
          blurRange.dispatchEvent(new Event('input'));
          methodSelect.dispatchEvent(new Event('change'));
          colorizeCheckbox.dispatchEvent(new Event('change'));
          edgeColorPicker.dispatchEvent(new Event('input'));
          contrastRange.dispatchEvent(new Event('input'));
          brightnessRange.dispatchEvent(new Event('input'));

          alert('Configuration loaded!');
        } else {
          alert('No configuration found.');
        }
      });

      // Initialize the application
      initCamera();

      // Clean up when the page is unloaded
      window.addEventListener('beforeunload', () => {
        if (video.srcObject) {
          video.srcObject.getTracks().forEach(track => track.stop());
        }
      });
    }
  </script>
</body>
</html>
